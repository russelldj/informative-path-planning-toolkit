from ipp_toolkit.config import UNCERTAINTY_KEY, MEAN_KEY
import numpy as np


class BaseInterestingessComputer:
    def compute_interestingness(self, prediction_dict: dict):
        """
        prediction_dict:
            The predictions generated by a predictor. It should contain
            a predicted value and optionally an uncertainty
        """
        raise NotImplementedError()


class UniformInterestingessComputer(BaseInterestingessComputer):
    def compute_interestingness(self, prediction_dict: dict):
        pred = prediction_dict[MEAN_KEY]
        uniform = np.ones_like(pred)
        return uniform


class UncertaintyInterestingessComputer(BaseInterestingessComputer):
    def compute_interestingness(self, prediction_dict: dict):
        try:
            uncertainty = prediction_dict[UNCERTAINTY_KEY]
            return uncertainty

        except KeyError:
            raise ValueError(
                "UncertaintyInterestingessComputer must be used with an UncertainPredictor"
            )


class RareClassInterestingnessComputer(BaseInterestingessComputer):
    def __init__(self, weighting_power=1):
        self.weighting_power = weighting_power

    def compute_interestingness(self, prediction_dict: dict):
        if MEAN_KEY in prediction_dict:
            predicted_classes = prediction_dict[MEAN_KEY]
            unique_values, counts = np.unique(predicted_classes, return_counts=True)
            inverse_counts = np.sum(counts) / counts
            inverse_counts = np.power(inverse_counts, self.weighting_power)
            per_sample_weighting = np.zeros_like(predicted_classes, dtype=float)
            for i, unique_value in enumerate(unique_values):
                per_sample_weighting[
                    unique_value == predicted_classes
                ] = inverse_counts[i]
        else:
            per_sample_weighting = None
        return per_sample_weighting
